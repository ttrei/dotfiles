proxy_cache_path /var/cache/nix levels=1:2 keys_zone=cachecache:100m max_size=20g inactive=365d use_temp_path=off;

# Cache only success status codes; in particular we don't want to cache 404s.
# See https://serverfault.com/a/690258/128321
map $status $cache_header {
    200     "public";
    302     "public";
    default "no-cache";
}

# access_log /var/log/nginx/access.log;

server {
    listen 0.0.0.0:80;
    listen [::0]:80;
    server_name 192.168.8.180;
    location / {
        root /var/public-nix-cache;
        expires max;
        add_header Cache-Control $cache_header always;
        # Ask the upstream server if a file isn't available locally
        error_page 404 = @fallback;
    }
    location = /nix-cache-info {
        proxy_pass $upstream_endpoint;
        proxy_cache cachecache;
        proxy_cache_valid  200 302  60d;
        expires max;
        add_header Cache-Control $cache_header always;
    }
    location @fallback {
        proxy_pass $upstream_endpoint;
        proxy_cache cachecache;
        proxy_cache_valid  200 302  60d;
        expires max;
        add_header Cache-Control $cache_header always;
    }
    # Using a variable for the upstream endpoint to ensure that it is
    # resolved at runtime as opposed to once when the config file is loaded
    # and then cached forever (we don't want that):
    # see https://tenzer.dk/nginx-with-dynamic-upstreams/
    # This fixes errors like
    #   nginx: [emerg] host not found in upstream "upstream.example.com"
    # when the upstream host is not reachable for a short time when
    # nginx is started.
    resolver 8.8.8.8;
    set $upstream_endpoint http://cache.nixos.org;
}
